<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Http协议 | 木易的OT</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="随笔杂谈">
    
    <link rel="preload" href="/my-vuepress-blog/assets/css/0.styles.0eca5e6d.css" as="style"><link rel="preload" href="/my-vuepress-blog/assets/js/app.5b95effd.js" as="script"><link rel="preload" href="/my-vuepress-blog/assets/js/3.09b549b0.js" as="script"><link rel="preload" href="/my-vuepress-blog/assets/js/1.61ee8a6d.js" as="script"><link rel="preload" href="/my-vuepress-blog/assets/js/39.299cd9df.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/js/10.93f745fb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/11.6d20f46d.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/12.a1a9071e.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/13.7d3d3afb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/14.1ee8b1c3.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/15.2f8f4d19.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/16.ec958f58.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/17.6dba1ae1.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/18.9010b644.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/19.1c7798ec.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/20.777fd7f9.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/21.8a493110.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/22.46433bb7.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/23.9de112aa.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/24.efeb1c7b.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/25.272a3678.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/26.810ea704.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/27.53a5d8d0.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/28.3aea0ffd.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/29.598d73b1.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/30.d6113ea0.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/31.085c6262.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/32.363daa26.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/33.e2a0acdb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/34.6765fbdf.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/35.7ce03bbb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/36.c6d15a86.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/37.dc069d2c.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/38.2d4de8e0.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/4.072fd4fb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/40.675f506c.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/41.030bdb69.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/42.9b46b6bb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/43.f48b8c66.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/44.07b9bc7d.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/45.f022c8e0.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/46.08cd9694.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/47.02131b69.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/48.9c5d599e.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/49.64ca210a.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/5.1c3238c4.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/50.70babce5.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/51.0eb64475.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/52.42177c82.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/53.14361df3.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/54.073b6248.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/55.f7329927.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/56.f897422a.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/57.fc6452fc.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/58.26c5850d.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/59.bb75ae9c.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/6.87b55cbb.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/60.cf148f56.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/61.bfe278a4.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/62.efe2862d.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/63.e1b7c0fc.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/64.d9c6f49b.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/65.1d3f6a9c.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/66.6ebec5ee.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/67.66339b46.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/7.f7fa5881.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/8.64def537.js"><link rel="prefetch" href="/my-vuepress-blog/assets/js/9.7159a8ac.js">
    <link rel="stylesheet" href="/my-vuepress-blog/assets/css/0.styles.0eca5e6d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>木易的OT</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>随笔杂谈</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>EricYangXD</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">木易的OT</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      木易的OT
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/EricYangXD" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/2295436007445021" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <h3 class="name" data-v-39576ba9>
    EricYangXD
  </h3> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>58</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/my-vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      木易的OT
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/EricYangXD" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/2295436007445021" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/" class="sidebar-heading clickable router-link-active"><span>About</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/handbook/React/SourceCode" class="sidebar-heading clickable"><span>React</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/handbook/Vue/SourceCode" class="sidebar-heading clickable"><span>Vue</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/handbook/LeetCode/BinaryTree" class="sidebar-heading clickable"><span>LeetCode</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/handbook/JavaScript/FrontEnd" class="sidebar-heading clickable"><span>JavaScript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>AntDesign</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-vuepress-blog/handbook/Skill/DevelopmentSkills" class="sidebar-heading clickable"><span>开发技巧</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>油猴</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机网络</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-vuepress-blog/handbook/Network/Http.html" aria-current="page" class="active sidebar-link">Http(s)协议相关知识</a></li><li><a href="/my-vuepress-blog/handbook/Network/TCP.html" class="sidebar-link">TCP协议相关知识</a></li><li><a href="/my-vuepress-blog/handbook/Network/DMZ.html" class="sidebar-link">DMZ区域</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Nodejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vite</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Google Chrome V8</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mac使用记录</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>文章诗句</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>Http协议</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>EricYangXD</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">Http协议</h1> <div data-v-f875f3fc><i class="iconfont reco-account" data-v-f875f3fc><span data-v-f875f3fc>EricYangXD</span></i> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>2022/1/4</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="http-协议"><a href="#http-协议" class="header-anchor">#</a> HTTP 协议</h2> <p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p> <p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p> <h3 id="http-请求构成"><a href="#http-请求构成" class="header-anchor">#</a> http 请求构成</h3> <ul><li>http: 请求行 + 头部信息 + 空白行 + body。</li> <li>tcp: tcp 头（至少 20 字节）+实际传输的数据（通常 1460 字节）。</li> <li>空白行的意义：按照 http 协议，空白行就是为了分隔 header 和 body，因为 http 是纯文本的协议。</li></ul> <h3 id="http-常用头字段"><a href="#http-常用头字段" class="header-anchor">#</a> http 常用头字段</h3> <p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p> <ol><li>通用字段：在请求头和响应头里都可以出现；</li> <li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li> <li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li> <li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li></ol> <h3 id="methods"><a href="#methods" class="header-anchor">#</a> Methods</h3> <p>在 HTTP 协议里，所谓的<code>安全</code>是指请求方法不会<code>破坏</code>服务器上的资源，即不会对服务器上的资源造成实质的修改。</p> <p>HEAD 方法可以看做是 GET 方法的一个<code>简化版</code>或者<code>轻量版</code>。因为它的响应头与 GET 完全相同，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的<code>元信息</code>。所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p> <table><thead><tr><th>方法 Method</th> <th>幂等 Idempotent</th> <th>安全 Safe</th> <th>可缓存 Cacheable</th></tr></thead> <tbody><tr><td>HEAD</td> <td>Y</td> <td>Y</td> <td>Y</td></tr> <tr><td>OPTIONS</td> <td>Y</td> <td>Y</td> <td>N</td></tr> <tr><td>GET</td> <td>Y</td> <td>Y</td> <td>Y</td></tr> <tr><td>PUT</td> <td>Y</td> <td>N</td> <td>N</td></tr> <tr><td>DELETE</td> <td>Y</td> <td>N</td> <td>N</td></tr> <tr><td>TRACE</td> <td>Y</td> <td>Y</td> <td>N</td></tr> <tr><td>POST</td> <td>N</td> <td>N</td> <td>Only if freshness information is included 包含新鲜度信息时</td></tr> <tr><td>PATCH</td> <td>N</td> <td>N</td> <td>N</td></tr> <tr><td>CONNECT</td> <td>N</td> <td>N</td> <td>N</td></tr></tbody></table> <h3 id="幂等"><a href="#幂等" class="header-anchor">#</a> 幂等</h3> <ul><li>Q: 什么是幂等性?</li> <li>A: 简单来说就是一个操作无论执行多少次，都会得到相同的结果，即 f(x)=f(f(x))。</li> <li>GET 和 HEAD 方法，它们是<code>只读</code>操作，很显然，GET 和 HEAD 既是安全的也是幂等的。</li> <li>DELETE 可以多次删除同一个资源，效果都是<code>资源不存在</code>，所以也是幂等的。</li> <li>POST 是<code>新增或提交数据</code>，多次提交数据会创建多个资源，所以不是幂等的。</li> <li>PUT 是<code>替换或更新数据</code>，多次更新一个资源，资源还是第一次更新的状态，所以是幂等的。</li></ul> <h3 id="options-方法"><a href="#options-方法" class="header-anchor">#</a> OPTIONS 方法</h3> <p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 <strong>OPTIONS</strong> 方法发起一个<strong>预检请求（preflight request）</strong>，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。在现在前端最常用的 CORS 跨域中，浏览器都是用 <strong>OPTIONS</strong> 方法发预检请求的。</p> <h3 id="patch-和-put-方法的区别"><a href="#patch-和-put-方法的区别" class="header-anchor">#</a> PATCH 和 PUT 方法的区别</h3> <ol><li>PATCH 方法是新引入的，是对 PUT 方法的补充，用来对已知资源进行局部更新;</li> <li>PATCH 请求中的实体是一组将要应用到实体的更改，而不是像 PUT 请求那样是要替换旧资源的实体;</li> <li>PATCH 只传要更新的字段到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段;</li> <li>PUT 虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象;</li> <li>PUT 是幂等的，而 PATCH 不一定是幂等的;</li> <li>PUT 更新整个资源，即整个集合，所以 PUT 是幂等的;</li> <li>PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改，所以不是幂等的，也就是，通过使用 PATCH，新资源可能被创造，或者现有资源被修改。</li> <li>POST 方法一定不是幂等的；多次执行同样的操作，每一次都会创建一个相同的新资源。</li></ol> <h3 id="杂记"><a href="#杂记" class="header-anchor">#</a> 杂记</h3> <ol><li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li> <li>HTTP 本质是无状态的，使用 Cookies 可以创建有状态的会话。</li> <li>实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器、操作系统对它的限制。同理，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制。</li> <li>还会包括「代理」的因素在里面，可能 url 太长还没到服务，就已经被代理拒绝掉了。</li> <li>一般浏览器对 URL 长度的最大限制从 2083 个字符（IE)到 19 万个字符（Opera)不等，Chrome-8182 个字符，Apache (Server)-8192 个字符，Firefox-65536 个字符，等等。</li> <li>一般，URL 如果包含汉字，会进行转换 encodeURIComponent，如果浏览器的编码为 UTF8 的话，一个汉字最终编码后的字符长度为 9 个字符。因此如果使用的 GET 方法，最大长度等于 URL 最大长度减去实际路径中的字符数。</li></ol> <h3 id="get-vs-post"><a href="#get-vs-post" class="header-anchor">#</a> GET VS POST</h3> <ol><li>多数浏览器对于 POST 采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于 GET），也就是第一步发送 header 数据，第二步再发送 body 部分。HTTP 是应用层的协议，而在传输层有些情况 TCP 会出现两次连结的过程，HTTP 协议本身不保存状态信息，一次请求一次响应。对于 TCP 而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用 GET 请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。</li> <li>GET 请求能够被 cache，GET 请求能够被保存在浏览器的浏览历史里面（密码等重要数据 GET 提交，别人查看历史记录，就可以直接看到这些私密数据）POST 不进行缓存。</li> <li>GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2048 字符，其他浏览器对 URL 长度限制实现上有所不同。POST 请求无长度限制（目前理论上是这样的）。</li> <li>GET 提交的数据大小，不同浏览器的限制不同，一般在 2k-8K 之间，POST 提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。</li> <li>安全性、幂等性、可缓存性。</li></ol> <h3 id="http-2-和-http-1-的区别"><a href="#http-2-和-http-1-的区别" class="header-anchor">#</a> HTTP/2 和 HTTP/1 的区别</h3> <ul><li>相对于 HTTP1.0，HTTP1.1 的优化：</li></ul> <ol><li>缓存处理：多了 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存信息（HTTTP1.0 If-Modified-Since,Expires）</li> <li>带宽优化及网络连接的使用</li> <li>错误通知的管理</li> <li>Host 头处理</li></ol> <ul><li><p>长连接： HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。单个 TCP 连接在同一时刻只能处理一个请求。一般不使用 Pipelining（一个支持持久连接的客户端可以在一个连接中发送多个请求，收到请求的服务器必须按照请求收到的顺序发送响应），因为有缺点：代理服务器不能正确处理 HTTP Pipelining、Head-of-line Blocking 连接头阻塞（首个请求耗时过长，阻塞其他请求）。Chrome 最多允许同一个 Host 可建立 6 个 TCP 连接。</p></li> <li><p>相对于 HTTP1.1，HTTP2 的优化：</p></li></ul> <ol><li>HTTP2 支持二进制传送（实现方便且健壮），HTTP1.x 是字符串传送</li> <li>HTTP2 支持多路复用 Multiplexing，一个 TCP 可以并发多个 HTTP 请求</li> <li>HTTP2 采用 HPACK 压缩算法压缩头部，减小了传输的体积</li> <li>HTTP2 支持服务端推送</li></ol> <h3 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h3> <table><thead><tr><th>code</th> <th>status</th> <th>intro</th></tr></thead> <tbody><tr><td>信息响应 (100–199)</td> <td></td> <td></td></tr> <tr><td>100</td> <td>接受，继续请求</td> <td>Continue</td></tr> <tr><td>101</td> <td>更换协议</td> <td>Switching Protocols</td></tr> <tr><td>成功响应 (200–299)</td> <td></td> <td></td></tr> <tr><td>200</td> <td>成功，并返回数据</td> <td>OK</td></tr> <tr><td>201</td> <td>已创建</td> <td>Created</td></tr> <tr><td>202</td> <td>已接受</td> <td>Accepted</td></tr> <tr><td>203</td> <td>成功，但未授权</td> <td>Non-Authoritative Information</td></tr> <tr><td>204</td> <td>成功，无内容</td> <td>No Content</td></tr> <tr><td>205</td> <td>成功，重置内容</td> <td>Reset Content</td></tr> <tr><td>206</td> <td>成功，部分内容</td> <td>Partial Content</td></tr> <tr><td>重定向消息 (300–399)</td> <td></td> <td></td></tr> <tr><td>300</td> <td>请求拥有不只一个响应</td> <td>Multiple Choice</td></tr> <tr><td>301</td> <td>永久移动，重定向</td> <td>Moved Permanently</td></tr> <tr><td>302</td> <td>临时移动，可使用原有 URI</td> <td>Found</td></tr> <tr><td>303</td> <td>指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源</td> <td>See Other</td></tr> <tr><td>304</td> <td>资源未修改，可使用协商缓存</td> <td>Not Modified</td></tr> <tr><td>客户端错误响应 (400–499)</td> <td></td> <td></td></tr> <tr><td>400</td> <td>客户端错误，如请求语法错误</td> <td>Bad Request</td></tr> <tr><td>401</td> <td>要求身份认证，客户端必须对自身进行身份验证</td> <td>Unauthorized</td></tr> <tr><td>403</td> <td>拒绝请求，客户端没有访问内容的权限</td> <td>Forbidden</td></tr> <tr><td>404</td> <td>资源不存在</td> <td>Not Found</td></tr> <tr><td>405</td> <td>目标资源不支持该方法</td> <td>Method Not Allowed</td></tr> <tr><td>408</td> <td>请求超时</td> <td>Request Timeout</td></tr> <tr><td>409</td> <td>请求与服务器的当前状态冲突</td> <td>Conflict</td></tr> <tr><td>服务端错误响应 (500–599)</td> <td></td> <td></td></tr> <tr><td>500</td> <td>服务器错误</td> <td>Internal Server Error</td></tr> <tr><td>501</td> <td>服务器不支持请求方法</td> <td>Not Implemented</td></tr> <tr><td>502</td> <td>网关错误的响应</td> <td>Bad Gateway</td></tr> <tr><td>503</td> <td>服务不可用，服务器没有准备好处理请求</td> <td>Service Temporarily Unavailable</td></tr> <tr><td>504</td> <td>网关响应超时</td> <td>Gateway Timeout</td></tr> <tr><td>505</td> <td>服务器不支持请求中使用的 HTTP 版本</td> <td>HTTP Version Not Supported</td></tr></tbody></table> <h2 id="http-缓存"><a href="#http-缓存" class="header-anchor">#</a> HTTP 缓存</h2> <h3 id="_1-强缓存"><a href="#_1-强缓存" class="header-anchor">#</a> 1. 强缓存</h3> <p>对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（ <code>Expires</code>、<code>Cache-Control</code> ）。</p> <ol><li><p><code>Expires</code> 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据；<code>Expires</code> 是 HTTP 1.0 的东西，现在浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。此外到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以 HTTP 1.1 的版本，使用 <code>Cache-Control</code> 替代。</p></li> <li><p><code>Cache-Control</code> 常见的取值有 <code>private</code>、<code>public</code>、<code>no-cache</code>、<code>max-age</code>，<code>no-store</code>，默认为 <code>private</code>。</p></li></ol> <ul><li>private: 是用户<code>私有</code>的，不能放在代理上与别人共享，客户端可以缓存，防止信息泄漏；</li> <li>public: 客户端和代理服务器都可缓存；</li> <li>max-age=xxx: 缓存的内容将在自「创建」 xxx 秒后失效；</li> <li>no-cache: 需要使用对比缓存来验证缓存数据；可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；</li> <li>no-store: 所有内容都不会缓存，强制缓存、对比缓存都不会触发；用于某些变化非常频繁的数据，例如秒杀页面；</li> <li>must-revalidate: 告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。</li> <li>proxy-revalidate: 只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</li> <li>s-maxage: 缓存的生存时间，只限定在代理上能够存多久，而客户端仍然使用<code>max-age</code>。</li> <li>no-transform: 代理专用的属性，代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而<code>no-transform</code>就会禁止这样做，不许<code>偷偷摸摸搞小动作</code>。</li> <li>Ctrl+F5 的<code>强制刷新</code>：其实是发了一个<code>Cache-Control: no-cache</code>，含义和<code>max-age=0</code>基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</li></ul> <ol start="3"><li>Pragma，HTTP/1.0 中规定的通用首部；用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 <code>Cache-Control</code> 还没有出来。 只有一个值<code>no-cache</code>，与 <code>Cache-Control: no-cache</code> 效果一致。</li></ol> <h3 id="_2-协商缓存"><a href="#_2-协商缓存" class="header-anchor">#</a> 2. 协商缓存</h3> <p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端可以使用缓存数据。缓存标识在请求 header 和响应 header 间进行传递，一共分为两种。</p> <ul><li><ol><li><code>Last-Modified(response header) / If-Modified-Since(request header)</code>:http1.0;</li></ol></li> <li><ol start="2"><li><code>ETag(response header) / If-None-Match(request header)</code>:http1.1;</li></ol></li></ul> <ol><li>ETag 在服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识，生成规则由服务器决定。</li> <li>ETag 优先级高于 Last-Modified，这里优先级指服务端优先级，客户端两者并存的情况下，都会在 request header 中带上，但是 Nginx 会优先匹配 Etag。</li> <li>ETag 还有<code>强``弱</code>之分。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个<code>W/</code>标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</li></ol> <h3 id="_3-例外-last-modified-命中强缓存"><a href="#_3-例外-last-modified-命中强缓存" class="header-anchor">#</a> 3. 例外：Last-Modified 命中强缓存</h3> <p>出现这种情况，一般是 Nginx 配置有问题，可以通过增加<code>add_header Cache-Control no-cache;</code>来解决。</p> <p>在我们的认知里，通常 <code>Last-Modified</code> 是和协商缓存相关，但一些情况下也会触发启发式(heuristic)缓存。</p> <p>如果服务器总是提供强缓存所需字段（ <code>Expires</code> 、 <code>Cache-Control</code> ），浏览器可以通过判断是否使用本地缓存文件，来实现更好的加载性能。但由于服务器不是总返回强缓存的 response 字段，此时浏览器会根据其他的 response header 字段来计算 <code>Cache-Control</code> 的 <code>max-age</code> 值（通常是 <code>Last-Modified</code> 字段）。HTTP/1.1 规范没有给出特定的实现算法，使得不同浏览器内核的浏览器对此表现不尽相同。</p> <p>通常推荐的计算方法是 过期时间 &lt; 时间间隔 _ 系数。时间间隔指的是 response 的返回时间与最后更新时间的间隔，而这个系数的典型值是 10%，计算公式为：<code>max-age = ( date - last-modified ) * 0.1</code>，绝大多数的客户端，包括浏览器和各类 app 都是采用的这一推荐算法。</p> <h3 id="http-缓存别再乱用了-推荐一个缓存设置的最佳姿势"><a href="#http-缓存别再乱用了-推荐一个缓存设置的最佳姿势" class="header-anchor">#</a> HTTP 缓存别再乱用了！推荐一个缓存设置的最佳姿势！</h3> <ol start="0"><li><p>资源的缓存通常是有多级的，一些缓存专门用于单个用户，一些缓存专用于多个用户。有些是由服务器控制的，有些是由用户控制的，有些则由中介层控制。缓存的种类：</p> <ul><li>浏览器缓存：一般并专用于单个用户，在浏览器客户端中实现。它们通过避免多次获取相同的响应来提高性能。</li> <li>本地代理：可能是用户自己安装的，也可能是由某个中介层管理的：比如公司的网络层或者网络提供商。本地代理通常会为多个用户缓存单个响应，这就构成了一种<code>公共</code>缓存。</li> <li>源服务器缓存/CDN。由服务器控制，源服务器缓存的目标是通过为多个用户缓存相同的响应来减少源服务器的负载。CDN 的目标是相似的，但它分布在全球各个地区，然后通过分配给最近的一组用户来达到减少延迟的目的。</li></ul></li> <li><p>为了防止中介缓存，建议设置：<code>Cache-Control: private</code>;</p></li></ol> <ul><li>禁用 Public Cache，减少了攻击者跨界访问到公共内存的可能性。</li></ul> <ol start="2"><li>建议设置适当的二级缓存 key：如果我们请求的响应是跟请求的 Cookie 相关的，建议设置：<code>Vary: Cookie;</code></li></ol> <ul><li>默认情况下，我们浏览器的缓存使用 URL 和 请求方法来做缓存 key 的。这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求 URL 和方法相同，数据会被缓存到一块内存里。这显然是有点问题，我们可以通过设置 <code>Vary: Cookie</code> 来避免这个问题。当用户身份信息发生变化的时候，缓存的内存也会发生变化。</li></ul> <h3 id="_200-状态码和-304-状态码何时出现"><a href="#_200-状态码和-304-状态码何时出现" class="header-anchor">#</a> 200 状态码和 304 状态码何时出现</h3> <ol><li><p>在没有设置 <code>Cache-Control</code> 的情况下，设置 <code>Last-Modified</code> 和 <code>ETag</code> 缓存，会出现 <code>200（from cache）</code>和 304 交替出现的情况。</p></li> <li><p>设置 <code>Cache-Control</code> 的情况下，过期刷新会出现 304(如果有更新内容，则是 200)，之后再过期之前刷新都是 <code>200（from cache）</code>。如果要确保要向服务端确认，可以将 <code>Cache-Control</code> 的 <code>max-age</code> 设置为 0。</p></li></ol> <h2 id="透视-http-协议"><a href="#透视-http-协议" class="header-anchor">#</a> 透视 HTTP 协议</h2> <div class="language-bash extra-class"><pre class="language-bash"><code>拷贝项目（需要Git）
<span class="token number">1</span>. <span class="token function">git</span> clone https://github.com/chronolaw/http_study

安装OpenResty （推荐使用Homebrew）
<span class="token number">1</span>. brew tap openresty/brew
<span class="token number">2</span>. brew <span class="token function">install</span> openresty

运行项目
<span class="token number">1</span>. <span class="token builtin class-name">cd</span> http_study/www/
<span class="token number">2</span>. openresty -p <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span> -c conf/nginx.conf

停止项目
<span class="token number">1</span>. openresty -s quit -p <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span> -c conf/nginx.conf
</code></pre></div><h2 id="http-版本对比"><a href="#http-版本对比" class="header-anchor">#</a> HTTP 版本对比</h2> <p>简单对比：</p> <ol><li>http1.0：最基础的 http 协议，支持基本的 get、post 方法</li> <li>http1.1：目前广泛应用，增加缓存策略 <code>cache-control|E-tag</code> 等；支持长连接 <code>Connection:keep-alive</code>，一次 TCP 连接可以多次请求；支持断点续传，状态码 206；支持新的方法 put、delete 等，可用于 restful api；</li> <li>http2.0：可压缩 header，减小体积；多路复用，一次 tcp 连接中可以多个 http 并行请求；支持服务端推送；</li></ol> <h3 id="http-特点"><a href="#http-特点" class="header-anchor">#</a> HTTP 特点</h3> <ol><li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；如传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等</li> <li>HTTP 是可靠传输协议，基于 TCP/IP 协议<code>尽量</code>保证数据的送达；</li> <li>HTTP 是应用层协议，比 FTP、SSH 等更通用、功能更多，能够传输任意数据；</li> <li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li> <li>HTTP 本质上是无状态的，明文传输，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。<code>明文</code>意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</li></ol> <p>优缺点对比：</p> <ol><li>HTTP 最大的优点是简单、灵活和易于扩展；</li> <li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li> <li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现<code>有状态</code>；</li> <li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li> <li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被篡改；</li> <li>HTTP 的性能不算差，但不完全适应现在的互联网，有<code>队头阻塞</code>等问题，还有很大的提升空间。</li></ol> <h2 id="websocket-和-http-的区别"><a href="#websocket-和-http-的区别" class="header-anchor">#</a> websocket 和 http 的区别</h2> <ol start="0"><li>浏览器有原生 api：<code>new WebSocket()</code>/<code>fetch</code>/<code>new XMLHttpRequest()</code>;</li> <li>websocket 协议名是：ws 或者 wss，可双端发起请求、接收信息，先通过 http 协议建立连接，然后升级到 websocket 协议，<code>status code = 101</code>，底层都是 tcp 协议；<code>101 Switching Protocols</code>：它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</li> <li>websocket 没有跨域限制；</li> <li>通过 send 和 onmessage 通讯，http 通过 request 和 response 通信；</li></ol> <ul><li>http 长轮询：用来模拟服务端推送的。客户端发起请求，服务端阻塞等待，不会立即返回响应而是等到有数据之后才返回响应，而客户端收到响应后，又会立即再发送一个请求到服务端。如此往复。长轮询需要处理 timeout 机制，即 timeout 之后重新发起请求。</li></ul> <h2 id="udp-和-http"><a href="#udp-和-http" class="header-anchor">#</a> UDP 和 http</h2> <p>对比一下 UDP 协议，它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理，也就是所谓的不可靠传输。</p> <p>而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文，可靠传输（因为是基于 TCP）。</p> <h2 id="中间人攻击"><a href="#中间人攻击" class="header-anchor">#</a> 中间人攻击</h2> <ol><li>https 加密过程，<a href="../assets/../../assets/zjrgj.png">加密过程</a></li> <li>中间人攻击，<a href="../assets/../../assets/zjr.png">原理</a></li></ol> <h2 id="uri-转译"><a href="#uri-转译" class="header-anchor">#</a> URI 转译</h2> <ol><li>URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；URI&gt;URL；</li> <li>URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；</li> <li>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。URI 转义的规则有点<code>简单粗暴</code>，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个<code>%</code>。对中文、日文等则通常使用 UTF-8 编码后再转义。</li> <li>前端常用的转译方法 encodeURI(url)和 encodeURIComponent(urlComponent)有何不同？
<ol><li>encodeURI()主要用于整个 URI，而 encodeURIComponent()主要用于对 URI 中的某一段进行编码。</li> <li>encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。</li></ol></li> <li>encodeURI 的原理：把字符（unicode）编码成 utf-8，utf-8 是用 1-4 个字节表示的，所以每个字节转换成 16 进制并在前面用百分号（%）连接，最后把每个字节转换的结果连接起来。</li></ol> <h2 id="mime-type"><a href="#mime-type" class="header-anchor">#</a> MIME type</h2> <p>「多用途互联网邮件扩展」（Multipurpose Internet Mail Extensions），简称为 MIME。HTTP 协议使用它可以检查传输的文件类型。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是<code>type/subtype</code>的字符串。简单列举一下在 HTTP 里经常遇到的几个类别：</p> <ol><li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li> <li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li> <li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li> <li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的<code>黑盒</code>，就会是 application/octet-stream，即不透明的二进制数据。</li></ol> <h2 id="encoding-type"><a href="#encoding-type" class="header-anchor">#</a> Encoding type</h2> <p>HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续<code>猜</code>，还需要有一个<code>Encoding type</code>，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。就少了很多，常用的只有下面三种：</p> <ol><li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li> <li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li> <li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）；</li></ol> <p>有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。</p> <p>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p> <p>Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里，遵循 UTF-8 字符编码方式的 Unicode 字符集也成为了互联网上的标准字符集。</p> <h2 id="传输大文件"><a href="#传输大文件" class="header-anchor">#</a> 传输大文件</h2> <ul><li>这种<code>化整为零</code>的思路在 HTTP 协议里就是<code>chunked</code>分块传输编码，在响应报文里用头字段<code>Transfer-Encoding: chunked</code>来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</li> <li><code>Transfer-Encoding: chunked</code>和<code>Content-Length</code>这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。</li> <li>当拖动进度条快进几分钟时，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。HTTP 协议为了满足这样的需求，提出了<code>范围请求</code>（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的<code>化整为零</code>。</li> <li>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段<code>Accept-Ranges: bytes</code>明确告知客户端：<code>我是支持范围请求的</code>。</li> <li>如果不支持的话该怎么办呢？服务器可以发送<code>Accept-Ranges: none</code>，或者干脆不发送<code>Accept-Ranges</code>字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</li> <li>看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：
<ul><li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li> <li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li> <li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li></ul></li> <li>分段的 range 和分块的 chunk 是两个完全无关的概念。chunk 是传输时分成小块逐个发送，接收到全部 chunk 之后会拼成完整的，而 range 是取大文件中间的一部分，收到之后不需要再拼接就可直接用，响应状态码必须是 206。</li> <li>范围请求一次也可以获取多个片段。</li></ul> <h2 id="tcp-长链接"><a href="#tcp-长链接" class="header-anchor">#</a> TCP 长链接</h2> <ul><li>TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</li> <li>在客户端，可以在请求头里加上<code>Connection: close</code>字段，告诉服务器：<code>这次通信后就关闭连接</code>。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</li> <li>关闭策略：
<ol><li>使用<code>keepalive_timeout</code>指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li> <li>使用<code>keepalive_requests</code>指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li></ol></li> <li>队头阻塞：参考「TCP 协议」中的「拥塞控制」。<code>队头阻塞</code>问题会导致性能下降，可以用<code>并发连接</code>和<code>域名分片</code>技术缓解。</li></ul> <h2 id="http-代理服务器"><a href="#http-代理服务器" class="header-anchor">#</a> HTTP 代理服务器</h2> <ol><li>HTTP 代理就是客户端和服务器通信链路中的一个中间环节，为两端提供<code>代理服务</code>；</li> <li>代理处于中间层，为 HTTP 处理增加了更多的灵活性，可以实现负载均衡、安全防护、数据过滤等功能；</li> <li>代理服务器需要使用字段<code>Via</code>标记自己的身份，多个代理会形成一个列表；</li> <li>如果想要知道客户端的真实 IP 地址，可以使用字段<code>X-Forwarded-For</code>和<code>X-Real-IP</code>；</li> <li>专门的<code>代理协议</code>可以在不改动原始报文的情况下传递客户端的真实 IP。</li> <li>反向代理中使用的负载均衡算法：1.随机；2.轮询；3.一致性 hash；4.最近最少使用；5.链接最少；6.ip_hash；7.最少连接数；8.最快连接数；</li></ol> <h2 id="http-缓存代理"><a href="#http-缓存代理" class="header-anchor">#</a> HTTP 缓存代理</h2> <p>HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理）。在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它<code>既是客户端，又是服务器</code>，同时也<code>既不是客户端，又不是服务器</code>。</p> <p>源服务器在设置完<code>Cache-Control</code>后必须要为报文加上<code>Last-modified</code>或<code>ETag</code>字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。</p> <ul><li>客户端的缓存控制：Cache-Control 中：
<ul><li><code>max-stale</code>的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。</li> <li><code>min-fresh</code>的意思是缓存必须有效，而且必须在 x 秒后依然有效。</li> <li>有的时候客户端还会发出一个特别的<code>only-if-cached</code>属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</li></ul></li> <li><code>Vary</code>字段，是内容协商的结果，相当于报文的一个版本标记。同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，<code>Vary: Accept-Encoding</code>/<code>Vary: User-Agent</code>，缓存代理必须要存储这些不同的版本。</li> <li><code>Purge</code>，也就是<code>缓存清理</code>，它对于代理也是非常重要的功能:
<ul><li>过期的数据应该及时淘汰，避免占用空间；</li> <li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li> <li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。</li></ul></li> <li>清理缓存的方法有很多，比较常用的一种做法是使用自定义请求方法<code>PURGE</code>，发给代理服务器，要求删除 URI 对应的缓存数据。</li></ul> <h2 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h2> <p>HTTPS 在 HTTP 下层的传输协议 TCP/IP 上又加了一层了 SSL/TLS，由<code>HTTP over TCP/IP</code>变成了<code>HTTP over SSL/TLS</code>，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。</p> <p>TLS（传输层安全，Transport Layer Security）由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。简单来说，SSL 就是通信双方通过非对称加密协商出一个用于对称加密的密钥。</p> <ul><li><p>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</p></li> <li><p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</p></li> <li><p><code>ECDHE-RSA-AES256-GCM-SHA384</code>:握手时使用 ECDHE 算法进行密钥交换，用 RSA 非对称加密算法进行签名和身份认证(身份认证和不可否认)，握手后的通信使用 AES 对称算法(机密性)，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数(完整性)。</p></li> <li><p>OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p></li> <li><p>通信安全必须同时具备机密性、完整性、身份认证和不可否认这四个特性；</p></li> <li><p>非对称加密为什么慢，非对称加密除了慢外还有什么缺点：</p> <ul><li>非对称加密基于大数运算，比如大素数或者椭圆曲线，是复杂的数学难题，所以消耗计算量，运算速度慢。</li> <li>除了慢，可能还有一个缺点就是需要更多的位数，相同强度的对称密钥要比非对称密钥短。对称密钥一般都 128 位、256 位，而 rsa 一般要 2048 位，不过椭圆曲线（ECC244）的会短一点。</li></ul></li> <li><p>TLS 里使用的混合加密方式：</p> <ul><li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</li> <li>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</li> <li>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</li> <li>即用非对称加密，加密对称加密的私钥。对称加密的私钥又是会话级的随机数=一次会话一个私钥。就算别人 baoli 破解也只是破解了一个会话。</li> <li>私钥加密用公钥解是为了做身份认证（数字签名），不可抵赖，因为默认私钥只有持有人知道</li></ul></li> <li><p>数字签名的原理其实很简单，就是把非对称加密的公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。因为默认私钥只有持有人知道。</p></li> <li><p>CA（Certificate Authority，证书认证机构）来解决公钥的信任链问题，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p></li> <li><p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。</p></li> <li><p>小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。</p></li> <li><p>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</p></li> <li><ol><li>摘要算法用来实现完整性，能够为数据生成独一无二的“指纹”，常用的算法是 SHA-2；</li></ol></li> <li><ol start="2"><li>数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；</li></ol></li> <li><ol start="3"><li>公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的；</li></ol></li> <li><ol start="4"><li>作为信任链的源头 CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任。</li></ol></li></ul> <h3 id="https-速度优化"><a href="#https-速度优化" class="header-anchor">#</a> https 速度优化</h3> <h4 id="硬件优化"><a href="#硬件优化" class="header-anchor">#</a> 硬件优化</h4> <ol><li>更快的 CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输。</li> <li>SSL 加速卡，加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力。（升级慢、支持算法有限，不能灵活定制解决方案）</li> <li>SSL 加速服务器，用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多。</li></ol> <h4 id="软件优化"><a href="#软件优化" class="header-anchor">#</a> 软件优化</h4> <ol><li>软件升级：把现在正在使用的软件尽量升级到最新版本。</li></ol> <h4 id="协议优化"><a href="#协议优化" class="header-anchor">#</a> 协议优化</h4> <ol><li>尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。</li> <li>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li> <li>椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。</li></ol> <h4 id="证书优化"><a href="#证书优化" class="header-anchor">#</a> 证书优化</h4> <ol><li>证书传输
<ul><li>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的“个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量，可谓“一举两得”。</li></ul></li> <li>证书验证
<ul><li>OCSP 装订：它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</li></ul></li></ol> <p>PS：</p> <ol><li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</li> <li>现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li> <li>OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。</li></ol> <h4 id="会话复用"><a href="#会话复用" class="header-anchor">#</a> 会话复用</h4> <p>HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。TLS 握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费。</p> <p>会话复用：主密钥缓存一下“重用”。可以免去一次 TLS 握手和计算的成本。</p> <ol><li>会话复用分两种，第一种叫“Session ID”，就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。</li> <li>第二种“Session Ticket”方案。会话票证。类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存。重连的时候，客户端使用扩展“session_ticket”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。</li></ol> <h4 id="预共享密钥"><a href="#预共享密钥" class="header-anchor">#</a> 预共享密钥</h4> <p>“False Start”“Session ID”“Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了“0-RTT”，原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</p> <p>但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送。</p> <p>解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放。</p> <h2 id="http-2"><a href="#http-2" class="header-anchor">#</a> HTTP/2</h2> <ol><li>HTTP 协议不再使用小版本号，只使用大版本号。与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</li> <li>HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；</li> <li>HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</li> <li>HTTP/2 报文不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。</li> <li>HTTP/2 使用二进制帧存放数据（数据分帧），通过「流」（stream，是虚拟的，实际上并不存在，二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID）可以实现同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。HTTP/2 的帧最大可以达到 16M。</li> <li>在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送。</li> <li>流 ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。</li> <li>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制。第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。
<ul><li>最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。</li> <li>当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。</li> <li>这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。</li> <li>响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。</li> <li>由于流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。</li> <li>下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送“GOAWAY”帧开一个新的 TCP 连接，流 ID 就又可以重头计数。流标识符的上限是 2^31，大约是 21 亿。</li></ul></li> <li>HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</li> <li>HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</li> <li>加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLS1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。</li> <li>HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。</li></ol> <h2 id="http-3-quic"><a href="#http-3-quic" class="header-anchor">#</a> HTTP/3 -- QUIC</h2> <ol><li>HTTP/3 基于 QUIC 协议，完全解决了“队头阻塞”问题，弱网环境下的表现会优于 HTTP/2；</li> <li>QUIC 是一个新的传输层协议，建立在 UDP 之上，实现了可靠传输；</li> <li>QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；</li> <li>QUIC 的连接使用“不透明”的连接 ID，不绑定在“IP 地址 + 端口”上，支持“连接迁移”；</li> <li>QUIC 的流与 HTTP/2 的流很相似，但分为双向流和单向流；</li> <li>HTTP/3 没有指定默认端口号，需要用 HTTP/2 的扩展帧“Alt-Svc”来发现。</li> <li>QUIC、HTTP/3 的好处:
<ul><li>彻底解决队头阻塞，</li> <li>用户态定义流量控制、拥塞避免等算法，</li> <li>优化慢启动、弱网、重建连接等问题。</li></ul></li></ol> <h2 id="网络应用防火墙-web-application-firewall-waf"><a href="#网络应用防火墙-web-application-firewall-waf" class="header-anchor">#</a> 网络应用防火墙（Web Application Firewall）-- WAF</h2> <p>WAF 是一种“防火墙”，它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。WAF 就是一种“HTTP 入侵检测和防御系统”。</p> <p>WAF 领域里的最顶级产品：ModSecurity，它可以说是 WAF 界“事实上的标准”。</p> <p>ModSecurity 有两个核心组件。第一个是“规则引擎”，它实现了自定义的“SecRule”语言，有自己特定的语法。但“SecRule”主要基于正则表达式，还是不够灵活，所以后来也引入了 Lua，实现了脚本化配置。</p> <p>ModSecurity 的第二个核心组件就是它的“规则集”。有了规则集，就可以在 Nginx 配置文件里加载，然后启动规则引擎。</p> <p>ModSecurity 还有强大的审计日志（Audit Log）功能，记录任何可疑的数据，供事后离线分析。</p> <p>WAF 实质上是模式匹配与数据过滤，所以会消耗 CPU，增加一些计算成本，降低服务能力，使用时需要在安全与性能之间找到一个“平衡点”。</p> <h2 id="cdn"><a href="#cdn" class="header-anchor">#</a> CDN</h2> <p>“内容”“分发”和“网络”。是专门为解决“长距离”上网络访问速度慢而诞生的一种网络应用服务。</p> <p>CDN 的最核心原则是“就近访问”。</p> <p>CDN 发展到现在已经有二十来年的历史了，早期的 CDN 功能比较简单，只能加速静态资源。随着这些年 Web 2.0、HTTPS、视频、直播等新技术、新业务的崛起，它也在不断进步，增加了很多的新功能，比如 SSL 加速、内容优化（数据压缩、图片格式转换、视频转码）、资源防盗链、WAF 安全防护等等。</p> <ol><li>CDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速；</li> <li>CDN 是具体怎么运行的：它有两个关键组成部分：全局负载均衡和缓存系统，对应的是 DNS 和缓存代理技术。</li> <li>GSLB 是 CDN 的“大脑”，使用 DNS 负载均衡技术，智能调度边缘节点提供服务；
<ol><li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；</li> <li>看用户所在的运营商网络，找相同网络的边缘节点；</li> <li>检查边缘节点的负载情况，找负载较轻的节点；</li> <li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li></ol></li> <li>缓存系统是 CDN 的“心脏”，使用 HTTP 缓存代理技术，缓存命中就返回给用户，否则就要回源。</li> <li>两个衡量 CDN 服务质量的指标：“命中率”和“回源率”。命中率就是命中次数与所有访问次数之比，回源率是回源次数与所有访问次数之比。
<ol><li>最基本的方式就是在存储系统上下功夫，硬件用高速 CPU、大内存、万兆网卡，再搭配 TB 级别的硬盘和快速的 SSD。软件方面则不断“求新求变”，各种新的存储软件都会拿来尝试，比如 Memcache、Redis、Ceph，尽可能地高效利用存储，存下更多的内容。</li> <li>缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，这样最终“扇入度”就缩小了，可以有效地减少真正的回源。</li> <li>使用高性能的缓存服务。</li></ol></li></ol> <h2 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h2> <ol><li>WebSocket 是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。</li> <li>WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</li> <li>WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据。</li> <li>WebSocket 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容。二进制帧结构比较简单，特殊的地方是有个“掩码”操作，客户端发数据必须掩码，服务器则不用；</li> <li>服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。</li> <li>WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。</li> <li>WebSocket 的帧头就四个部分：“结束标志位 + 操作码 + 帧长度 + 掩码”，只是使用了变长编码的“小花招”，不像 HTTP/2 定长报文头那么简单明了。</li> <li>和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据。利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制，这也是 WebSocket 与 HTTP 的另一个重要关联点。</li> <li>WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：
<ul><li>“Connection: Upgrade”，表示要求协议“升级”；</li> <li>“Upgrade: websocket”，表示要“升级”成 WebSocket 协议。</li></ul></li> <li>为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：
<ul><li>Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；</li> <li>Sec-WebSocket-Version：协议的版本号，当前必须是 13。</li></ul></li> <li>服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信。</li></ol> <h2 id="http-性能优化"><a href="#http-性能优化" class="header-anchor">#</a> HTTP 性能优化</h2> <ol><li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li> <li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li> <li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li> <li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li> <li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li> <li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li> <li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li> <li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li> <li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li> <li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li> <li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。
<ol><li>对于 HTTP/2 来说，一个域名使用一个 TCP 连接才能够获得最佳性能，如果开多个域名，就会浪费带宽和服务器资源，也会降低 HTTP/2 的效率，所以“域名收缩”在 HTTP/2 里是必须要做的。</li> <li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。</li> <li>而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li></ol></li></ol> <h2 id="http-四次挥手的原因"><a href="#http-四次挥手的原因" class="header-anchor">#</a> HTTP 四次挥手的原因</h2> <ul><li>第一个 rtt</li></ul> <ol><li>主动关闭方发送 FIN 到被动关闭方；进入 FIN_WAIT；</li> <li>被动关闭方收到 FIN 并回复 ACK 给主动关闭方；进入 CLOSE_WAIT;</li> <li>主动关闭方收到 ACK 之后，不再发送新的请求了，进入 FIN_WAIT2；</li></ol> <ul><li>第二个 rtt</li></ul> <ol start="4"><li>被动关闭方检查之后发现已经不需要继续再发送数据（之前的请求都已响应完毕），发送 FIN 给主动关闭方；进入 LAST_ACK；</li> <li>主动关闭方收到 FIN 之后，发送 ACK 给被动关闭方，再等待一段时间（2MSL）即进入关闭状态，此时主动关闭方 CLOSED；</li> <li>被动关闭方收到 ACK 之后，也进入关闭状态，此时被动关闭方也 CLOSED；</li></ol> <p>主要有两个原因，一个是为了让被动关闭方能够按照正常步骤进入 CLOSED 状态，二是为了防止已经失效的请求连接报文出现在下次连接中。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2022/6/5 18:25:21</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/my-vuepress-blog/handbook/TamperMonkey/Plugin.html" class="prev">
            油猴常用插件
          </a></span> <span class="next"><a href="/my-vuepress-blog/handbook/Network/TCP.html">
            TCP协议相关知识
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-协议" class="sidebar-link reco-side-http-协议" data-v-cb1513f6>HTTP 协议</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-请求构成" class="sidebar-link reco-side-http-请求构成" data-v-cb1513f6>http 请求构成</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-常用头字段" class="sidebar-link reco-side-http-常用头字段" data-v-cb1513f6>http 常用头字段</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#methods" class="sidebar-link reco-side-methods" data-v-cb1513f6>Methods</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#幂等" class="sidebar-link reco-side-幂等" data-v-cb1513f6>幂等</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#options-方法" class="sidebar-link reco-side-options-方法" data-v-cb1513f6>OPTIONS 方法</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#patch-和-put-方法的区别" class="sidebar-link reco-side-patch-和-put-方法的区别" data-v-cb1513f6>PATCH 和 PUT 方法的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#杂记" class="sidebar-link reco-side-杂记" data-v-cb1513f6>杂记</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#get-vs-post" class="sidebar-link reco-side-get-vs-post" data-v-cb1513f6>GET VS POST</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-2-和-http-1-的区别" class="sidebar-link reco-side-http-2-和-http-1-的区别" data-v-cb1513f6>HTTP/2 和 HTTP/1 的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-状态码" class="sidebar-link reco-side-http-状态码" data-v-cb1513f6>HTTP 状态码</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-缓存" class="sidebar-link reco-side-http-缓存" data-v-cb1513f6>HTTP 缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#_1-强缓存" class="sidebar-link reco-side-_1-强缓存" data-v-cb1513f6>1. 强缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#_2-协商缓存" class="sidebar-link reco-side-_2-协商缓存" data-v-cb1513f6>2. 协商缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#_3-例外-last-modified-命中强缓存" class="sidebar-link reco-side-_3-例外-last-modified-命中强缓存" data-v-cb1513f6>3. 例外：Last-Modified 命中强缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-缓存别再乱用了-推荐一个缓存设置的最佳姿势" class="sidebar-link reco-side-http-缓存别再乱用了-推荐一个缓存设置的最佳姿势" data-v-cb1513f6>HTTP 缓存别再乱用了！推荐一个缓存设置的最佳姿势！</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#_200-状态码和-304-状态码何时出现" class="sidebar-link reco-side-_200-状态码和-304-状态码何时出现" data-v-cb1513f6>200 状态码和 304 状态码何时出现</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#透视-http-协议" class="sidebar-link reco-side-透视-http-协议" data-v-cb1513f6>透视 HTTP 协议</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-版本对比" class="sidebar-link reco-side-http-版本对比" data-v-cb1513f6>HTTP 版本对比</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-特点" class="sidebar-link reco-side-http-特点" data-v-cb1513f6>HTTP 特点</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#websocket-和-http-的区别" class="sidebar-link reco-side-websocket-和-http-的区别" data-v-cb1513f6>websocket 和 http 的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#udp-和-http" class="sidebar-link reco-side-udp-和-http" data-v-cb1513f6>UDP 和 http</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#中间人攻击" class="sidebar-link reco-side-中间人攻击" data-v-cb1513f6>中间人攻击</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#uri-转译" class="sidebar-link reco-side-uri-转译" data-v-cb1513f6>URI 转译</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#mime-type" class="sidebar-link reco-side-mime-type" data-v-cb1513f6>MIME type</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#encoding-type" class="sidebar-link reco-side-encoding-type" data-v-cb1513f6>Encoding type</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#传输大文件" class="sidebar-link reco-side-传输大文件" data-v-cb1513f6>传输大文件</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#tcp-长链接" class="sidebar-link reco-side-tcp-长链接" data-v-cb1513f6>TCP 长链接</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-代理服务器" class="sidebar-link reco-side-http-代理服务器" data-v-cb1513f6>HTTP 代理服务器</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-缓存代理" class="sidebar-link reco-side-http-缓存代理" data-v-cb1513f6>HTTP 缓存代理</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#https" class="sidebar-link reco-side-https" data-v-cb1513f6>HTTPS</a></li><li class="level-3" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#https-速度优化" class="sidebar-link reco-side-https-速度优化" data-v-cb1513f6>https 速度优化</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-2" class="sidebar-link reco-side-http-2" data-v-cb1513f6>HTTP/2</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-3-quic" class="sidebar-link reco-side-http-3-quic" data-v-cb1513f6>HTTP/3 -- QUIC</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#网络应用防火墙-web-application-firewall-waf" class="sidebar-link reco-side-网络应用防火墙-web-application-firewall-waf" data-v-cb1513f6>网络应用防火墙（Web Application Firewall）-- WAF</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#cdn" class="sidebar-link reco-side-cdn" data-v-cb1513f6>CDN</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#websocket" class="sidebar-link reco-side-websocket" data-v-cb1513f6>WebSocket</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-性能优化" class="sidebar-link reco-side-http-性能优化" data-v-cb1513f6>HTTP 性能优化</a></li><li class="level-2" data-v-cb1513f6><a href="/my-vuepress-blog/handbook/Network/Http.html#http-四次挥手的原因" class="sidebar-link reco-side-http-四次挥手的原因" data-v-cb1513f6>HTTP 四次挥手的原因</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/my-vuepress-blog/assets/js/app.5b95effd.js" defer></script><script src="/my-vuepress-blog/assets/js/3.09b549b0.js" defer></script><script src="/my-vuepress-blog/assets/js/1.61ee8a6d.js" defer></script><script src="/my-vuepress-blog/assets/js/39.299cd9df.js" defer></script>
  </body>
</html>
